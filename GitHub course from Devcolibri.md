## GitHub course from Devcolibri

### lesson 0

В начале необходимо пройти глобальную инициализацию

```bash
git config --global user.name "Sam"
```

Данное имя будет отображаться для всех наших коммитов, то есть другие разработчики будут видеть данное имя.

```bash
git config --global user.email "sam@encom.com"
```

После заходим в директорию где мы бы хотели создать свой проект

```bash
mkdir git-sample
cd git-sample/
git init 
```

Ответ

```
Инициализирован пустой репозиторий Git в /home/sam/git-sample/.git/
```

Чтобы увидеть новую папку и зайти на неё

```bash
ls -a
cd .git
```

Тут есть файл конфиг в котором сохраняются некоторые данные. Попробуем сделать локальную конфигурацию.

```bash
git config user.name "Test User"
git config user.email "test@encom.com"
```

После этого мы увидем в файле ```config``` изменения

```
[core]
	repositoryformatversion = 0
	filemode = true
	bare = false
	logallrefupdates = true
[user]
	name = Test User
	email = test@encom.com
```



### lesson 1 "Первый коммит"

Создадит местовый файл `test.txt`, напишем там что угодно. После

```bash
git add test.txt
```

Сделаем теперь коммит и сразу укажем комментарий к нашему коммиту

```bash
git commit -m "First Commit"
```

Скачаем дефолтный интерфейсный редактор в котором мы можем смотреть все наши коммиты.

```bash
sudo apt install gitk
```

После давай редактируем `test.txt` и снова закоммитим его

После изменения сначала добавляем его

```bash
git add test.txt
git commit -m "Secondary Commit"
```

Теперь наинтерес открой `gitk` и посмотри изменения.

### lesson 2 "Проверка состояния"

```bash
git status
```

### lesson 3 "Индексация файлов"

Когда мы вводим `git add test.txt`, то мы на самом деле индексируем его. То есть до индексации утилита не может видеть изменения связаные с этим файлов и может отображать неточные данные данные в `git status`,  но после индексации, она будет видеть изменения которые были сделаны с файлом.

Также если мы переименовали файл, например `test.txt` в `testio.txt`. Для гита это означает что мы удалили файл `test.txt` и создали новый файл `testio.txt`. При проверке статуса при индексации, она именно так и будет отображать. Однако после индексации она отобразит что файл был переименован. Причем если мы добавляем в индексации по именам файлов то старое имя тоже надо индексировать.

Либо есть команды для быстрой индексации файлов

Добавляем на коммит кондидат (индексируем) все файлы во всех папках

```bash
git add *
```

Индексируем файлы только в текущей директории

```bash
git add .
```



### lesson 4 "История коммитов"

Посмотреть историю коммитов

```bash
git log
```

```
commit bce5b1c485a4b67ac98dcbdc27d005b216010251 (HEAD -> master)
Author: Test User <test@encom.com>
Date:   Sun Apr 26 15:29:24 2020 +0300

    Secondary commit

commit ef87d1f2072268554149946a187bc2e3a1608feb
Author: Test User <test@encom.com>
Date:   Sun Apr 26 14:29:42 2020 +0300

    Secondary commit

commit 40b66df75bcffd66ad8b277b34516ec7cc78bd0e
Author: Test User <test@encom.com>
Date:   Sun Apr 26 14:27:00 2020 +0300

    First Commit
```

Если вводить с некоторыми настройками

```bash
git log --pretty=oneline
```

```
bce5b1c485a4b67ac98dcbdc27d005b216010251 (HEAD -> master) Secondary commit
ef87d1f2072268554149946a187bc2e3a1608feb Secondary commit
40b66df75bcffd66ad8b277b34516ec7cc78bd0e First Commit
```

```bash
git log --pretty=oneline --max-count=2
```

```
bce5b1c485a4b67ac98dcbdc27d005b216010251 (HEAD -> master) Secondary commit
ef87d1f2072268554149946a187bc2e3a1608feb Secondary commit
```

```bash
git log --pretty=oneline --all
git log --pretty=oneline --author="Test User"
```

```bash
git log --pretty=format:"%h - %s : %ad [%an]"
```

```
bce5b1c - Secondary commit : Sun Apr 26 15:29:24 2020 +0300 [Test User]
ef87d1f - Secondary commit : Sun Apr 26 14:29:42 2020 +0300 [Test User]
40b66df - First Commit : Sun Apr 26 14:27:00 2020 +0300 [Test User]
```

```bash
git log --pretty=format:"%h - %s : %ad [%an]" --date=short
```

```
bce5b1c - Secondary commit : 2020-04-26 [Test User]
ef87d1f - Secondary commit : 2020-04-26 [Test User]
40b66df - First Commit : 2020-04-26 [Test User]
```

### lesson 5 "Git checkout"

Checkout нужен для того чтобы переключиться на определенный коммит определенной ветки дерева. Точки остановы snapshot's.

Для того чтобы вернуться на определенный коммит, нужно знать хэш коммита (из логов)

```bash
git checkout 40b66df
```

Если что-то пошло не так и какой-то функционал перестал работать, то с помощью данной команды. Чекаем и находим коммит когда всё работало и после переходим обратно в текущее состояние и исправляем всё.

```bash
git checkout master
```

вместо master мы сможем написать название нашей ветки если нужно  будет.



### lesson 6 "Отмена индексированных файлов"

Мы можем вернуть состояние либо всей ветки, либо всего коммита, либо отдельного файла

```bash
git reset HEAD testos.txt
```

HEAD - это то последнее состояние в котором был, в нашем случае файл, до того как были произведены в нём изменения. Либо вместо HEAD можно указать хэш нужного коммита как в предыдущем уроке.

Теперь гит забыл про изменения в указанном файлов, будто он его и не индексировал. Но состояние самого файла не вернулось к нужному значению. И чтобы окончательно удалить изменения, нужно

```bash
git checkout testos.txt
```



### lesson 7 "Revert - Отмена коммита"

Если нам нужно вернуться в состояние прошлого коммита

```bash
git revert HEAD --no-edit
```

Реверт останется в истории. Есть другой способ без сохранения в истории но лучше этим не пользоваться. Если выполнять эту команду то он будет всё дальше и дальше откатываться в коммита, вплоть до изначального состояния. Либо вместо HEAD можно указать хэш нужного коммита. Но вполне вероятно возникнет конфликтная ситуация которую гит не смог сразу решить.



### lesson 8 "Решение простого конфликта"

Если не хотим исправлять конфликт и поняли что сделали это ошибочно, то можно ввести

```bash
git revert --abort
```

Но если хотим исправить, то

Исправляем сначала ошибку, потом 

```bash
git revert --continue
```

либо коммитим, я если честно совсем не понял этот урок, в комментах куча замечаний, так что может это и не так страшно.



### lesson 9 "Ветки и их применение"

Посмотреть все ветки

```bash
git branch
```

Создадим новую ветку testbranch

```bash
git checkout -b testbranch
```

Git Flow

Переключиться на ветку master

```bash
git checkout master
```



### lesson 10 "Слияние веток и решение конфликтов слияния"

Для того чтобы совершить слияние двух веток, переходим на ту ветку в которую будем делать слияние, в нашем случае эта ветка **master**, после, для того чтобы провести слияние в текущую ветку слить ветку **dev**

```shell
git merge dev
```

Всё, слияние произошло.

https://coderoad.ru/51795774/%D1%80%D0%B5%D1%88%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BA%D0%BE%D0%BD%D1%84%D0%BB%D0%B8%D0%BA%D1%82%D0%B0-%D1%81%D0%BB%D0%B8%D1%8F%D0%BD%D0%B8%D1%8F-%D0%B2-vim

Во время слияния могут произойти конфликты, например в обоих ветках мы изменили один и тот же файл. Пока что я в поиске необходимой утилиты для решения конфликтов. Необходимо найти такую утилиту чтобы было легко их решать когда мы имеем дело с множеством файлами.

А так можно воспользоваться уже имеющейс утилитой, но она не совсем удобна.

```shell
git mergetool
```

В **mergetool** есть такие команты как

* Ctrl + w -> - перемещение в окно справа
* :diffoff - заблокировать окно
* :diffthis - разблокировать окно
* do - произвести копирование с незаблокированного окна в окно MERGE
* :xa - произвести слияние

После этого стоит всё закоммитить и удалить лишные файлы. Это всё непрактичто, но пока что имеем.



### lesson 11 "rebase vs merge - Что такое git rebase?"

rebase отличается от merge, тем что при слиянии через merge все коммиты которые были в обоих ветках сохраняются в реальной последовательности. А при объединение веток через rebase коммиты текущей ветки становятся последними, а коммиты присоединенной ветки идут перед текущими.

dev: r-2, r-4

master: r-1, -3

rebase: r-2, r-4, r-1, r-3

+++

dev: c-2, c-4

master: c-1, c-3

merge: c-1, c-2, c-3, c-4

***

rebase рекомендуется использовать в локальных ветках, в публичных лучше испольовать merge

***

### lesson 12 "Удаленный репозиторий и git clone"

Мы может с сайта GitHub залить к себе на комп какой-нибудь проект (репозиторий)

```shell
git clone https://github.com/geekcomputers/PythonScripts
```

Теперь у нас появится папка проекта PythonScripts, переходим в него и теперь будто мы сами локально над ним работали, нам доступно всё, весь код и более того гит жирнали, то есть какие ветки существуют, какие изменени вносились, слияния и тп.

Сами регаемся на айте гитхаба и создаем там репозиторий. И нас есть два вариант как действовать с этим удаленным репозиторием, как заливать туда наш проект.

Создать новый репозиторий в командном окне

```shell
echo "# sorter" >> README.md
git init
git add README.md
git commit -m "first commit"
git remote add origin https://github.com/kurtatter/sorter.git
git push -u origin master
```

Либо существующий репозиторий из командной строки

```shell
git remote add origin https://github.com/kurtatter/sorter.git
git push -u origin master
```

---

### lesson 13 "Загружаем изменения на удаленный репозиторий"

Короче чтобы отправить наш локальный репозиторий на удаленным, в гитхабе уже должен существовать репозиторий с таки же именем, иначе он просто скажет "да пошел ты". То есть ту ссылку которые мы указываем при git remote add она должна быть реально, уже существующей, если ее нет, то он ее не создаст.

---

Меняем что-нибудь у нас, потом индексируем всё это и коммитим. После, просто набираем

```shell
git push
```

Всё. Возможно он попросит логин и пароль и файлы отправятся в удаленки, по умолчанию в ветку master.

---

Рассмотрим как выполнять пушить отдельные ветки.

```shell
git push origin dev
```

Отправить в удаленный репозиторий ветку **dev**



### lesson 14 "Обновляем код манерой merge и rebase"

```shell
git pull origin dev
```

Эта команда вытягивает проект из удаленного репозитория, ветку dev.

Либо можно сделать, что на уделенке один файл был изменен, у нас на локалке тоже изменен другой файл и мы короче набираем

```shell
git pull --rebase origin master
```

Чтобы он вытанул и объеденил всё как rebase, потому что он обычно вытягивает и объединяет всё как merge.

Так просто легче всё структуировать и упрявлять всем.

---

### lesson 15 "Что такое Origin и для чего нужен stash?"

**stash** это как корзина в которую мы можем прятать некоммиченные изменения в файлах.

И например, из-за того что мы что-то не заккомитили на локалке и из-за этоно не пулить с удаленки, то мы пока что можем спрятать нажи незакоммиченные изменения, запулить, после уже решать как поступать с спрятанными незакомиченными изменениями.

Спрятать незакоммиченные изменения

```shell
git stash
```

Запулим с удаленки

```shell
git pull --rebase origin master
```

Посмотрим какие у нас есть спрятанные изменения 

```shell
git stash list
```

```shell
stash@{0}: WIP on master: b08dc37 join
stash@{1}: WIP on master: b08dc37 join
```

Это значит у нас есть два изменения.

Стереть последнее изменение в стеше

```shell
git stash drop
```

И он сотрет последнее изменение

посмотреть последнее изменение

```shell
git stash show
```

Применить последнее изменение добавленное в наш стеш

```shell
git stash apply
```

При этом после применения, изменения всё равно остается в корзине, и тут главное не забыть и не запутаться, что мы не убрали последнее изменение с корзины.

В отличии от apply есть команда которая достает изменение и сразу удаляет его с корзины

```shell
git stash pop
```

Мы можем полность очистить корзину и ничего отуда не вытаскивать

```shell
git stash clear
```

#### что такое origin

Чтобы посореть с каким удаланным сервером мы работает и какие  вообще есть удаленные сервера, для этого есть команда:

```shell
git remote
```

и он покажет 

```shell
origin
```

Origin это то название которое гит сервера дают по умолчанию для нового репозитория

Мы можем создавать свои удаленные репозитории кроме оригинала.

```shell
git remote -v
```

С каким удаленными репозиториями мы сейчас работаем.